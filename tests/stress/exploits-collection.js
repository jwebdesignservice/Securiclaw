// STRESS TEST: Known Exploits Collection
// ALL OF THESE MUST BE DETECTED AS CRITICAL/HIGH

// ========== CODE EXECUTION ==========

// Test 1: eval() variants
function test_eval_basic() {
  eval(userInput);
}

function test_eval_indirect() {
  const e = eval;
  e('malicious code');
}

function test_eval_window() {
  window.eval(userInput);
}

// Test 2: Function constructor variants
function test_function_basic() {
  new Function(userInput)();
}

function test_function_indirect() {
  const F = Function;
  new F('return ' + userInput)();
}

// Test 3: setTimeout/setInterval with strings
function test_settimeout_string() {
  setTimeout(userInput, 100);
}

function test_setinterval_string() {
  setInterval('doSomething(' + userInput + ')', 1000);
}

// ========== COMMAND INJECTION ==========

const cp = require('child_process');

// Test 4: exec with concatenation
function test_exec_concat() {
  cp.exec('ls -la ' + userInput);
}

// Test 5: spawn with array (safe) vs string (unsafe)
function test_spawn_unsafe() {
  cp.spawn('sh', ['-c', 'echo ' + userInput]);
}

// Test 6: execSync
function test_execsync() {
  cp.execSync(`cat /etc/passwd | grep ${userInput}`);
}

// ========== SQL INJECTION ==========

// Test 7: String concatenation
function test_sql_concat(userId) {
  db.query("SELECT * FROM users WHERE id = " + userId);
}

// Test 8: Template literal
function test_sql_template(table, column, value) {
  db.query(`SELECT * FROM ${table} WHERE ${column} = '${value}'`);
}

// Test 9: Dynamic table name
function test_sql_dynamic_table(tableName) {
  connection.execute("DROP TABLE " + tableName);
}

// Test 10: UNION injection
function test_sql_union(search) {
  mysql.query("SELECT * FROM products WHERE name LIKE '%" + search + "%'");
}

// ========== XSS ==========

// Test 11: innerHTML
function test_xss_innerhtml(data) {
  document.getElementById('output').innerHTML = data;
}

// Test 12: outerHTML
function test_xss_outerhtml(html) {
  element.outerHTML = '<div>' + html + '</div>';
}

// Test 13: document.write
function test_xss_document_write(content) {
  document.write(content);
}

// Test 14: insertAdjacentHTML
function test_xss_insert(markup) {
  div.insertAdjacentHTML('beforeend', markup);
}

// ========== PROTOTYPE POLLUTION ==========

// Test 15: Object.assign without filtering
function test_prototype_assign(userInput) {
  const config = {};
  Object.assign(config, JSON.parse(userInput));
}

// Test 16: Spread operator
function test_prototype_spread(data) {
  const obj = { ...JSON.parse(data) };
}

// Test 17: Recursive merge
function test_prototype_merge(target, source) {
  for (let key in source) {
    if (typeof source[key] === 'object') {
      target[key] = test_prototype_merge(target[key] || {}, source[key]);
    } else {
      target[key] = source[key];
    }
  }
  return target;
}

// ========== PATH TRAVERSAL ==========

const fs = require('fs');

// Test 18: readFile with concatenation
function test_path_readfile(filename) {
  fs.readFile('/uploads/' + filename, 'utf8');
}

// Test 19: writeFile with user path
function test_path_writefile(filepath, data) {
  fs.writeFileSync(filepath, data);
}

// Test 20: require with dynamic path
function test_path_require(moduleName) {
  require('./' + moduleName);
}

// ========== SSRF ==========

// Test 21: fetch with user URL
function test_ssrf_fetch(url) {
  fetch(url).then(res => res.json());
}

// Test 22: axios with template
function test_ssrf_axios(endpoint) {
  axios.get(`http://internal-api/${endpoint}`);
}

// Test 23: http.request
const http = require('http');
function test_ssrf_http(host, path) {
  http.request({ host: host, path: path });
}

// ========== NOSQL INJECTION ==========

// Test 24: MongoDB with string interpolation
function test_nosql_mongo(username) {
  db.collection('users').findOne({ username: username });
}

// Test 25: MongoDB with $where
function test_nosql_where(condition) {
  db.collection('users').find({ $where: condition });
}

// ========== DESERIALIZATION ==========

// Test 26: JSON.parse without validation
function test_deser_json(data) {
  const obj = JSON.parse(data);
  processObject(obj);
}

// Test 27: eval-based deserialization
function test_deser_eval(serialized) {
  return eval('(' + serialized + ')');
}

// ========== XXE ==========

// Test 28: XML parsing without protection
const xml2js = require('xml2js');
function test_xxe_xml(xmlData) {
  xml2js.parseString(xmlData, (err, result) => {
    console.log(result);
  });
}

// ========== OPEN REDIRECT ==========

// Test 29: res.redirect with user input
function test_redirect(req, res) {
  res.redirect(req.query.url);
}

// Test 30: Location header
function test_location_header(req, res) {
  res.setHeader('Location', req.body.redirectUrl);
  res.status(302).end();
}

module.exports = {
  // All test functions exported for validation
};
