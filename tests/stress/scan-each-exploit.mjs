import { runAudit } from '../../src/lib/security/audit.ts';

// Test each exploit pattern individually
const exploits = [
  { id: 1, code: `function test() { eval(userInput); }`, type: 'eval basic' },
  { id: 2, code: `function test() { const e = eval; e('code'); }`, type: 'eval indirect' },
  { id: 3, code: `function test() { window.eval(userInput); }`, type: 'eval window' },
  { id: 4, code: `function test() { new Function(userInput)(); }`, type: 'Function constructor' },
  { id: 5, code: `function test() { const F = Function; new F('code')(); }`, type: 'Function indirect' },
  { id: 6, code: `function test() { setTimeout(userInput, 100); }`, type: 'setTimeout string' },
  { id: 7, code: `function test() { setInterval('doSomething(' + userInput + ')', 1000); }`, type: 'setInterval string' },
  { id: 8, code: `const cp = require('child_process'); function test() { cp.exec('ls ' + userInput); }`, type: 'exec concat' },
  { id: 9, code: `const cp = require('child_process'); function test() { cp.spawn('sh', ['-c', 'echo ' + userInput]); }`, type: 'spawn unsafe' },
  { id: 10, code: `const cp = require('child_process'); function test() { cp.execSync('cat /etc/passwd | grep ' + userInput); }`, type: 'execSync' },
  { id: 11, code: `function test(userId) { db.query("SELECT * FROM users WHERE id = " + userId); }`, type: 'SQL concat' },
  { id: 12, code: 'function test(t,c,v) { db.query(`SELECT * FROM ${t} WHERE ${c} = \'${v}\'`); }', type: 'SQL template' },
  { id: 13, code: `function test(t) { connection.execute("DROP TABLE " + t); }`, type: 'SQL DROP' },
  { id: 14, code: `function test(s) { mysql.query("SELECT * FROM products WHERE name LIKE '%" + s + "%'"); }`, type: 'SQL UNION' },
  { id: 15, code: `function test(d) { document.getElementById('output').innerHTML = d; }`, type: 'XSS innerHTML' },
  { id: 16, code: `function test(h) { element.outerHTML = '<div>' + h + '</div>'; }`, type: 'XSS outerHTML' },
  { id: 17, code: `function test(c) { document.write(c); }`, type: 'XSS document.write' },
  { id: 18, code: `function test(m) { div.insertAdjacentHTML('beforeend', m); }`, type: 'XSS insertAdjacent' },
  { id: 19, code: `function test(u) { const cfg = {}; Object.assign(cfg, JSON.parse(u)); }`, type: 'Prototype assign' },
  { id: 20, code: `function test(d) { const obj = { ...JSON.parse(d) }; }`, type: 'Prototype spread' },
  { id: 21, code: `function merge(t, s) { for (let k in s) { t[k] = s[k]; } return t; }`, type: 'Prototype merge' },
  { id: 22, code: `const fs = require('fs'); function test(f) { fs.readFile('/uploads/' + f, 'utf8'); }`, type: 'Path readFile' },
  { id: 23, code: `const fs = require('fs'); function test(p, d) { fs.writeFileSync(p, d); }`, type: 'Path writeFile' },
  { id: 24, code: `function test(m) { require('./' + m); }`, type: 'Dynamic require' },
  { id: 25, code: `function test(url) { fetch(url).then(r => r.json()); }`, type: 'SSRF fetch' },
  { id: 26, code: 'function test(e) { axios.get(`http://internal-api/${e}`); }', type: 'SSRF axios' },
  { id: 27, code: `const http = require('http'); function test(h, p) { http.request({ host: h, path: p }); }`, type: 'SSRF http' },
  { id: 28, code: `function test(u) { db.collection('users').findOne({ username: u }); }`, type: 'NoSQL findOne' },
  { id: 29, code: `function test(c) { db.collection('users').find({ $where: c }); }`, type: 'NoSQL $where' },
  { id: 30, code: `function test(req, res) { res.redirect(req.query.url); }`, type: 'Open redirect' },
];

console.log('=== SCANNING EACH EXPLOIT INDIVIDUALLY ===\n');

let detected = 0;
let missing = [];

exploits.forEach(exploit => {
  const result = runAudit(exploit.code);
  const hasIssues = result.issues.length > 0;
  const hasCriticalOrHigh = result.issues.some(i => i.severity === 'critical' || i.severity === 'high');
  
  if (hasIssues && hasCriticalOrHigh) {
    console.log(`✅  ${exploit.id}. ${exploit.type} - ${result.issues.length} issue(s), score: ${result.securityScore}`);
    detected++;
  } else if (hasIssues) {
    console.log(`⚠️  ${exploit.id}. ${exploit.type} - Only LOW/MED issues, score: ${result.securityScore}`);
    missing.push(exploit);
  } else {
    console.log(`❌  ${exploit.id}. ${exploit.type} - NO DETECTION, score: ${result.securityScore}`);
    missing.push(exploit);
  }
});

console.log(`\n=== SUMMARY ===`);
console.log(`Detected with CRITICAL/HIGH: ${detected}/30`);
console.log(`Missing or weak detection: ${missing.length}/30`);

if (missing.length > 0) {
  console.log(`\n=== GAPS TO FIX ===`);
  missing.forEach(m => {
    const result = runAudit(m.code);
    console.log(`\n${m.id}. ${m.type}:`);
    console.log(`   Score: ${result.securityScore}`);
    if (result.issues.length > 0) {
      result.issues.forEach(i => {
        console.log(`   - [${i.severity.toUpperCase()}] ${i.type}: ${i.description.substring(0, 60)}`);
      });
    } else {
      console.log(`   - No issues detected`);
    }
  });
}
